# Copyright: 2011,2012 MoinMoin:ThomasWaldmann
# Copyright: 2024-2025 MoinMoin:UlrichB
# License: GNU GPL v2 (or any later version), see LICENSE.txt for details.

"""
MoinMoin - validation for storage metadata and data.

Validation modes:

trusted == False: for metadata coming from user input (such as a web form) â€”
                  in this mode some values will be forced (e.g., mtime,
                  address, hostname, ...).

trusted == True: for metadata coming from trusted sources (such as loading
                 backups or running tests).

The mode trusted=True/False and the values for forcing can be given as extra
parameters to store_revision (see the indexing module).

If supplied metadata is missing required values that have sane defaults,
validators may insert the defaults into the metadata or reject the data.
"""

from __future__ import annotations

import time
import re

from flatland import Dict, Element, List, Unset, Boolean, Integer, String
from flatland.validation import Validator

from moin import log
from moin.constants import keys
from moin.constants.contenttypes import CONTENTTYPE_DEFAULT, CONTENTTYPE_USER
from moin.storage.types import ItemData, MetaData, ValidationState
from moin.utils.crypto import make_uuid, UUID_LEN
from moin.utils.mime import Type

logging = log.getLogger(__name__)


class DuckDict(Dict):
    # in duck mode, keys unknown to the schema will not cause errors
    policy = "duck"


class UuidValidator(Validator):
    """
    Validate a UUID value (must be a hex unicode string of specific length).
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="Uuid value must be of type str")
        if len(v) != UUID_LEN:
            return self.note_error(element, state, message=f"Uuid value must be of length {UUID_LEN}")
        try:
            int(v, 16)  # is this hex?
            return True
        except ValueError:
            return self.note_error(element, state, message="Uuid must be hex value")


uuid_validator = UuidValidator()


class ItemidValidator(Validator):
    """
    Validate an itemid - a UUID value that identifies an item.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if not state["trusted"] or element.raw is Unset:
            fqname = state[keys.FQNAME]
            itemid = fqname.value if fqname and fqname.field == keys.ITEMID else state.get(keys.ITEMID)
            if itemid is None:
                # this is first revision of an item
                itemid = make_uuid()
            element.set(itemid)
        return uuid_validator(element, state)


class RevidValidator(Validator):
    """
    Validate a revid - a UUID value that identifies an item revision.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            # revid will be autogenerated by store
            return True
        return uuid_validator(element, state)


class UseridValidator(Validator):
    """
    Validate a userid - a UUID value that identifies a user (profile).
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if not state["trusted"]:
            userid = state[keys.USERID]
            element.set(userid)
            if userid is None:
                # unknown user is acceptable
                return True
        return element.raw is Unset or uuid_validator(element, state)


class NameValidator(Validator):
    """
    Validate a (item/revision) name.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            element.set(state[keys.NAME])
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="Name value must be of type str")
        if v != v.strip():
            return self.note_error(element, state, message="Name value must not be surrounded by whitespace characters")
        if v.startswith("+"):  # used for views, like /+meta/<itemname>
            return self.note_error(element, state, message="Name value must not start with '+'")
        if v.startswith("/") or v.endswith("/"):
            return self.note_error(element, state, message="Name value must not start/end with '/'")
        if "//" in v:  # empty ancestor name is invalid
            return self.note_error(element, state, message="Name value must not contain '/'")
        return True


name_validator = NameValidator()


class ItemlinkValidator(Validator):
    """
    Validate an itemlink element value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            element.set(state[keys.NAME])
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="Itemlink value must be of type str")
        if v != v.strip():
            return self.note_error(
                element, state, message="Itemlink value must not be surrounded by whitespace characters"
            )
        if v.startswith("/") or v.endswith("/"):
            return self.note_error(element, state, message="Itemlink may not start or end with '/'.")
        if "//" in v:  # empty ancestor name is invalid
            return self.note_error(element, state, message="Itemlink may not contain '/'.")
        return True


class TagValidator(Validator):
    """
    Validate a tag value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            return True
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="Tag value must be of type str")
        if v != v.strip():
            return self.note_error(element, state, message="Tag value must not be surrounded by whitespace characters")
        return True


tag_validator = TagValidator()


class NamespaceValidator(Validator):
    """
    Validate a namespace (part of a wiki site) value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            element.set(state[keys.NAMESPACE])
        v = element.value
        if v is None:
            return True  # the routing middleware can extract namespace from the name
        return name_validator(element, state)


namespace_validator = NamespaceValidator()


class UserContentTypeValidator(Validator):
    """
    Validate a user profile content type value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            element.set(CONTENTTYPE_USER)
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="'user_contenttype' value must be of type str")
        return v == CONTENTTYPE_USER


class ContentTypeValidator(Validator):
    """
    Validate a supported content type value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            ct = state.get("contenttype_current")
            if ct is None:
                ct = state.get("contenttype_guessed")
                if ct is None:
                    ct = CONTENTTYPE_DEFAULT
            element.set(ct)
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="'contenttype' value must be of type str")
        ct = Type(v)
        if ct.type not in ["text", "image", "audio", "video", "application"]:
            return self.note_error(element, state, message=f"'contenttype' is not valid: {ct.type}")
        if not ct.subtype:
            return self.note_error(element, state, message="'contenttype' with missing subtype")
        if ct.type == "text":
            charset = ct.parameters.get("charset")
            if charset is None:
                # we must have the charset, otherwise decoding is impossible
                return self.note_error(element, state, message="'contenttype' without charset")
            if charset.lower() not in ["ascii", "utf-8"]:
                # currently we do not recode
                return self.note_error(element, state, message="'contenttype' with invalid charset")
        return True


class ModificationTimeValidator(Validator):
    """
    Validate a modification time (UNIX timestamp) attribute value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:

        # set item modification time if not already set
        if element.raw is Unset:
            now = int(time.time())
            element.set(now)

        v = element.value
        if not isinstance(v, int):
            return self.note_error(element, state, message="'mtime' value must be an integer")

        # TODO: some tests still use 1, 2, 3, ...
        if not state["trusted"] and v < 31 * 24 * 3600:
            # we don't have negative values nor timestamps from Jan 1970,
            # this likely was some crap 0 +/- maybe tz adjustments
            return self.note_error(element, state, message="Found bad 'mtime' value: {v}")

        return True


class ActionValidator(Validator):
    """
    Validate an action value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if not state["trusted"]:
            element.value = state[keys.ACTION]
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="'action' must be of type str")
        if v not in [
            keys.ACTION_SAVE,
            keys.ACTION_REVERT,
            keys.ACTION_TRASH,
            keys.ACTION_COPY,
            keys.ACTION_RENAME,
            keys.ACTION_CONVERT,
        ]:
            return self.note_error(element, state, message=f"'action' has invalid value {v}")
        return True


class AclValidator(Validator):
    """
    Validate an ACL, also checks if changing ACL is allowed.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            return True
        if state["trusted"]:
            if element.value is None:
                return self.note_error(element, state, message="'acl' can't be None")
        else:  # untrusted
            v = element.value
            if not isinstance(v, str):
                return self.note_error(element, state, message="'acl' must be of type str")
            # TODO check parent revision acl / whether acl would be changed
            # acl_changed = v != state['acl_parent']
            # is_admin = False
            # if acl_changed and not is_admin:
            #    return False
        return True


class CommentValidator(Validator):
    """
    Validate a comment.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            return True
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="'comment' must be of type str")
        # TODO: check if comment was somehow invalid, e.g. contained html
        return True


class HostnameValidator(Validator):
    """
    Validate a hostname (DNS name).
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if not state["trusted"]:
            # addr = state[keys.ADDRESS] # TODO
            element.value = None  # TODO: lookup(addr)
            return True
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="'hostname' must be of type str")
        return True


class AddressValidator(Validator):
    """
    Validate an IP address.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if not state["trusted"]:
            element.value = state[keys.ADDRESS]
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="'address' must be of type str")
        return True


class SizeValidator(Validator):
    """
    Validate a content size.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            # size is set in the storage code, so everything is acceptable
            return True
        v = element.value
        try:
            element.value = v = int(v)
        except (TypeError, ValueError):
            return self.note_error(element, state, message="'size' must be convertable to int")
        if v < 0:
            return self.note_error(element, state, message="'size' must no be less than 0")
        return True


class HashValidator(Validator):
    """
    Validate a content hash.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        if element.raw is Unset:
            # hash is set in the storage code, so everything is acceptable
            return True
        v = element.value
        if not isinstance(v, str):
            return self.note_error(element, state, message="'sha1' must be of type str")
        if len(v) != keys.HASH_LEN:
            return False
        try:
            int(v, 16)  # is this hex?
            return True
        except ValueError:
            return self.note_error(element, state, message="'sha1' must be a hex value")


class SubscriptionValidator(Validator):
    """
    Validate a subscription value.
    """

    def validate(self, element: Element, state: ValidationState) -> bool:
        try:
            keyword, value = element.value.split(":", 1)
        except ValueError:
            return self.note_error(element, state, message="Subscription must contain colon delimiters.")

        if keyword in (keys.ITEMID,):
            value_element = String(value)
            valid = uuid_validator(value_element, state)
        elif keyword in (keys.NAME, keys.TAGS, keys.NAMERE, keys.NAMEPREFIX):
            try:
                namespace, value = value.split(":", 1)
            except ValueError:
                return self.note_error(element, state, message="Subscription must contain 2 colon delimiters.")
            namespace_element = String(namespace)
            if not namespace_validator(namespace_element, state):
                return self.note_error(element, state, message="Not a valid namespace value.")
        else:
            return self.note_error(
                element,
                state,
                message="Subscription must start with one of the keywords: "
                "'{}', '{}', '{}', '{}' or '{}'.".format(
                    keys.ITEMID, keys.NAME, keys.TAGS, keys.NAMERE, keys.NAMEPREFIX
                ),
            )

        value_element = String(value)
        if keyword == keys.TAGS:
            valid = tag_validator(value_element, state)
        elif keyword in (keys.NAME, keys.NAMEPREFIX):
            valid = name_validator(value_element, state)
        elif keyword == keys.NAMERE:
            try:
                re.compile(value, re.U)
                valid = True
            except re.error:
                valid = False
        if not valid:
            return self.note_error(element, state, message="Subscription has invalid value.")
        return True


common_meta = (
    String.named(keys.ITEMID).validated_by(ItemidValidator()),
    String.named(keys.REVID).validated_by(RevidValidator()),
    String.named(keys.PARENTID).validated_by(uuid_validator).using(optional=True),
    String.named(keys.NAMESPACE).using(strip=False).validated_by(namespace_validator),
    List.named(keys.NAME).of(String.using(strip=False).validated_by(name_validator)).using(optional=True),
    List.named(keys.NAME_OLD).of(String.using(strip=False).validated_by(name_validator)).using(optional=True),
    Integer.named(keys.MTIME).validated_by(ModificationTimeValidator()),
    String.named(keys.ACTION).validated_by(ActionValidator()),
    String.named(keys.ACL).validated_by(AclValidator()),
    String.named(keys.COMMENT).validated_by(CommentValidator()),
    String.named(keys.ADDRESS).validated_by(AddressValidator()),
    String.named(keys.HOSTNAME).validated_by(HostnameValidator()).using(optional=True),
    List.named(keys.TAGS).of(String.named("tag").validated_by(TagValidator())).using(optional=True),
)

ContentMetaSchema = DuckDict.named("ContentMetaSchema").of(
    String.named(keys.CONTENTTYPE).validated_by(ContentTypeValidator()),
    String.named(keys.USERID).validated_by(UseridValidator()),
    Integer.named(keys.SIZE).validated_by(SizeValidator()),
    String.named(keys.HASH_ALGORITHM).validated_by(HashValidator()),
    String.named(keys.DATAID).validated_by(uuid_validator).using(optional=True),
    # markup items may have this:
    List.named(keys.ITEMLINKS).of(String.named("itemlink").validated_by(ItemlinkValidator())).using(optional=True),
    List.named(keys.ITEMTRANSCLUSIONS)
    .of(String.named("itemtransclusion").validated_by(NameValidator()))
    .using(optional=True),
    # TODO: CONTENT validation? can we do it here?
    *common_meta,
)

UserMetaSchema = DuckDict.named("UserMetaSchema").of(
    String.named(keys.CONTENTTYPE).validated_by(UserContentTypeValidator()),
    String.named(keys.EMAIL).using(optional=True),
    String.named(keys.ENC_PASSWORD).using(optional=True),
    String.named(keys.RECOVERPASS_KEY).using(optional=True),
    String.named(keys.THEME_NAME).using(optional=True),
    String.named(keys.TIMEZONE).using(optional=True),
    String.named(keys.LOCALE).using(optional=True),
    String.named(keys.CSS_FILE).using(optional=True),
    Integer.named(keys.RESULTS_PER_PAGE).using(optional=True),
    Integer.named(keys.EDIT_ROWS).using(optional=True),
    Boolean.named(keys.DISABLED).using(optional=True),
    Boolean.named(keys.WANT_TRIVIAL).using(optional=True),
    Boolean.named(keys.SHOW_COMMENTS).using(optional=True),
    Boolean.named(keys.EDIT_ON_DOUBLECLICK).using(optional=True),
    Boolean.named(keys.USE_HTML_EDITOR).using(optional=True),
    Boolean.named(keys.USE_MARKDOWN_EDITOR).using(optional=True),
    Boolean.named(keys.SCROLL_PAGE_AFTER_EDIT).using(optional=True),
    Boolean.named(keys.MAILTO_AUTHOR).using(optional=True),
    Boolean.named(keys.ISO_8601).using(optional=True),
    List.named(keys.QUICKLINKS).of(String.named("quicklinks")).using(optional=True),
    List.named(keys.SUBSCRIPTIONS)
    .of(String.named("subscription").validated_by(SubscriptionValidator()))
    .using(optional=True),
    List.named(keys.EMAIL_SUBSCRIBED_EVENTS).of(String.named("email_subscribed_event")).using(optional=True),
    # TODO: DuckDict.named('bookmarks').using(optional=True),
    *common_meta,
)


def validate_data(meta: MetaData, data: ItemData) -> bool:
    """
    Validate the data contents, if possible.

    :param meta: metadata dict
    :param data: data file
    :return: validation ok [bool]
    """
    ct = Type(meta[keys.CONTENTTYPE])
    if ct.type != "text":
        # we can't validate non-text mimetypes, so assume it is ok
        return True

    coding = ct.parameters["charset"].lower()
    if coding not in ["ascii", "utf-8"]:
        # checking 8bit encodings this way is pointless, decoding never raises
        return True

    text_bytes = data.read()
    data.seek(0)  # rewind, so it can be read again
    try:
        text_bytes.decode(coding)
        return True
    except UnicodeDecodeError:
        logging.info("Item data contains an invalid string value (decoding error).")
        return False
